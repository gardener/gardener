apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  labels:
    app: istio-ingressgateway
    foo: bar
  name: apiserver-tls-termination
  namespace: test-ingress
spec:
  workloadSelector:
    labels:
      app: istio-ingressgateway
      foo: bar
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: GATEWAY
      listener:
        portNumber: 9443
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
            subFilter:
              name: "envoy.filters.http.router"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": "type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
          defaultSourceCode:
            inlineString: |
              function envoy_on_request(request_handle)
                -- Drop headers used by kube-apiserver authentication proxy.
                local remove = {"X-Remote-User", "X-Remote-Group"}
                for key, value in pairs(remove) do
                  request_handle:headers():remove(value)
                end

                local streamInfo = request_handle:streamInfo()
                local ssl = streamInfo:downstreamSslConnection()

                -- Parse client certificate subject.
                local parsedSubject = ssl:parsedSubjectPeerCertificate()
                if parsedSubject then
                  -- Get the host from the request and set it as dynamic metadata.
                  local host = streamInfo:requestedServerName()
                  streamInfo:dynamicMetadata():set("envoy.filters.http.lua", "authenticated-kube-apiserver-host", host)

                  local cn = parsedSubject:commonName()
                  -- Kill request if CN is empty.
                  if cn == "" then
                    request_handle:respond({[":status"] = "400"}, "Invalid certificate subject")
                  end

                  -- Add request headers for kube-apiserver authentication.
                  -- Istio is an authenticating proxy in this case, so we must set the defined headers accordingly.
                  -- https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy
                  -- CN of the client certificate defines the username, O defines groups.
                  -- see https://kubernetes.io/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts
                  request_handle:headers():add("X-Remote-User", cn)

                  local os = parsedSubject:organizationName()
                  for _, o in ipairs(os) do
                    if o ~= "" then
                      request_handle:headers():add("X-Remote-Group", o)
                    end
                  end
                end

                -- Route timeouts to upstream have to be disabled. Otherwise, watches would be terminated after 15 seconds.
                -- See https://www.envoyproxy.io/docs/envoy/latest/faq/configuration/timeouts#route-timeouts
                request_handle:headers():add("x-envoy-upstream-rq-timeout-ms", "0")
                request_handle:headers():add("x-envoy-upstream-rq-per-try-timeout-ms", "0")
              end
